package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"eventify/api/graphql/generated"
	"eventify/api/graphql/models"
	"eventify/internal/domain"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// ID is the resolver for the id field.
func (r *eventResolver) ID(ctx context.Context, obj *domain.Event) (string, error) {
	return obj.Id.String(), nil
}

// Date is the resolver for the date field.
func (r *eventResolver) Date(ctx context.Context, obj *domain.Event) (string, error) {
	return obj.Date.Format("2006-01-02T15:04:05Z07:00"), nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *eventResolver) CreatedBy(ctx context.Context, obj *domain.Event) (string, error) {
	return obj.CreatedBy.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *eventResolver) CreatedAt(ctx context.Context, obj *domain.Event) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *eventResolver) UpdatedAt(ctx context.Context, obj *domain.Event) (*string, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	updatedAt := obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")
	return &updatedAt, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input models.CreateEventInput) (*models.CreateEventResponse, error) {
	r.telemetryAdapter.TrackEvent(ctx, "graphql_create_event", map[string]string{
		"event_name": input.Name,
		"location":   input.Location,
	})

	// Parse date string to time.Time
	date, err := time.Parse("2006-01-02T15:04:05Z07:00", input.Date)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_name": input.Name,
			"error":      "invalid_date_format",
		})
		return nil, err
	}

	// Convert input to domain model
	event := &domain.Event{
		Name:        input.Name,
		Description: input.Description,
		Date:        date,
		Location:    input.Location,
		Organizer:   input.Organizer,
		Category:    input.Category,
		Tags:        input.Tags,
		Capacity:    input.Capacity,
	}

	err = r.eventService.CreateEvent(event, ctx)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_name": input.Name,
		})
		return nil, err
	}

	return &models.CreateEventResponse{
		EventID: event.Id.String(),
		Message: "Event created successfully",
	}, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id string, input models.UpdateEventInput) (*models.UpdateEventResponse, error) {
	r.telemetryAdapter.TrackEvent(ctx, "graphql_update_event", map[string]string{
		"event_id": id,
	})

	// Parse UUID
	eventID, err := uuid.Parse(id)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_id": id,
		})
		return nil, err
	}

	// Get existing event
	existingEvent := r.eventService.GetEventById(eventID, ctx)
	if existingEvent == nil {
		return nil, fmt.Errorf("event not found")
	}

	// Update fields if provided
	if input.Name != nil {
		existingEvent.Name = *input.Name
	}
	if input.Description != nil {
		existingEvent.Description = *input.Description
	}
	if input.Date != nil {
		date, err := time.Parse("2006-01-02T15:04:05Z07:00", *input.Date)
		if err != nil {
			r.telemetryAdapter.TrackError(err, map[string]string{
				"event_id": id,
			})
			return nil, err
		}
		existingEvent.Date = date
	}
	if input.Location != nil {
		existingEvent.Location = *input.Location
	}
	if input.Organizer != nil {
		existingEvent.Organizer = *input.Organizer
	}
	if input.Category != nil {
		existingEvent.Category = *input.Category
	}
	if input.Tags != nil {
		existingEvent.Tags = input.Tags
	}
	if input.Capacity != nil {
		existingEvent.Capacity = *input.Capacity
	}

	err = r.eventService.UpdateEvent(existingEvent, ctx)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_id": id,
		})
		return nil, err
	}

	return &models.UpdateEventResponse{
		Event:   existingEvent,
		Message: "Event updated successfully",
	}, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (*models.DeleteEventResponse, error) {
	r.telemetryAdapter.TrackEvent(ctx, "graphql_delete_event", map[string]string{
		"event_id": id,
	})

	// Parse UUID
	eventID, err := uuid.Parse(id)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_id": id,
		})
		return nil, err
	}

	err = r.eventService.DeleteEvent(eventID, ctx)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_id": id,
		})
		return nil, err
	}

	return &models.DeleteEventResponse{
		Message: "Event deleted successfully",
	}, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*domain.Event, error) {
	r.telemetryAdapter.TrackEvent(ctx, "graphql_get_event", map[string]string{
		"event_id": id,
	})

	// Parse UUID
	eventID, err := uuid.Parse(id)
	if err != nil {
		r.telemetryAdapter.TrackError(err, map[string]string{
			"event_id": id,
		})
		return nil, err
	}

	event := r.eventService.GetEventById(eventID, ctx)
	if event == nil {
		return nil, fmt.Errorf("event not found")
	}

	return event, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, page *int, limit *int) (*models.ListEventsResponse, error) {
	r.telemetryAdapter.TrackEvent(ctx, "graphql_list_events", map[string]string{
		"page":  fmt.Sprintf("%v", page),
		"limit": fmt.Sprintf("%v", limit),
	})

	events := r.eventService.GetAllEvents(ctx)

	// Convert to response model
	eventModels := make([]*domain.Event, len(events))
	for i, event := range events {
		eventModels[i] = &event
	}

	// Handle nil pointers for page and limit
	pageValue := 0
	if page != nil {
		pageValue = *page
	}
	limitValue := 0
	if limit != nil {
		limitValue = *limit
	}

	return &models.ListEventsResponse{
		Events: eventModels,
		Total:  len(events),
		Page:   pageValue,
		Limit:  limitValue,
	}, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *domain.User) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *domain.User) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *userResolver) UpdatedAt(ctx context.Context, obj *domain.User) (*string, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	updatedAt := obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")
	return &updatedAt, nil
}

// Event returns generated.EventResolver implementation.
func (r *Resolver) Event() generated.EventResolver { return &eventResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
